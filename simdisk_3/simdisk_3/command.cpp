#include "pch.h"
#include <iostream>
#include <windows.h>
#include "command.h"
#include "function.h"
#include "sync.h"

using namespace std;

//info ????????????
void info()
{
	cout << "-------- ???Linux???????? --------" << endl;
	cout << right << setw(15) << "??????:" << setw(15) << BLOCK_GROUP_NUM << " ??" << endl;
	cout << right << setw(15) << "????????:" << setw(15) << BLOCK_NUM_PER_GROUP << " ??" << endl;
	cout << right << setw(15) << "?????:" << setw(15) << TOTAL_BLOCK_NUM << " ??" << endl;
	cout << right << setw(15) << "????§³:" << setw(15) << BLOCK_SIZE << " ???" << endl;
	cout << right << setw(15) << "????????:" << setw(15) << TOTAL_BLOCK_NUM * BLOCK_SIZE << " ???" << endl;
	cout << right << setw(15) << "??????????:" << setw(15) << (TOTAL_BLOCK_NUM - blockgroup[0].superblock.free_block_num) * BLOCK_SIZE << " ???" << endl;
	cout << right << setw(15) << "?????????:" << setw(15) << blockgroup[0].superblock.free_block_num * BLOCK_SIZE << " ???" << endl;
}

//cd ?????
void cd(const char *path)
{
	Directory tempdir;
	int pathlen = strlen(path);
	if (pathlen == 0) {
		cout << "???¡¤???: " << current_path << endl;
		return;
	}
	//??¡¤???????????
	if (get_dir(path, pathlen, tempdir)) {
		//?§Ø?i???????????§Õ??
		if (sharedm_read(tempdir.inode_no)) {
			cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}
		//?§Ø????????
		if (inode_table[tempdir.inode_no].fileaccess == WRITE_ONLY && current_usertype != ROOT_USER) {
			cout << "??????§Õ, ??????, ?§Ý??????" << endl;
			return;
		}
		current_dir = tempdir;
		show_cur_path(current_dir);
	}
	else {
		cout << "????????, ?§Ý??????" << endl;
		return;
	}
}

//dir ?????
void dir(const char *path, int is_subdir)
{
	Directory tempdir;
	int pathlen = strlen(path);
	if (get_dir(path, pathlen, tempdir)) { //????¡¤???????????????
		//?§Ø?i???????????§Õ??
		if (sharedm_read(tempdir.inode_no)) {
			cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}
		//?§Ø????????
		if (inode_table[tempdir.inode_no].fileaccess == WRITE_ONLY && current_usertype != ROOT_USER) {
			cout << "??????§Õ, ??????, ????????" << endl;
			return;
		}
		cout << endl;
		if (is_subdir == 1) {
			cout << "??" << inode_table[tempdir.inode_no].fdname << "??????????: " << endl;
			cout << left << setw(15) << "????" << setw(25) << "??????" << setw(10) << "????" << setw(10) << "??§³(B)" << setw(15) << "??????" << setw(10) << "????" << setw(10) << "???????" << endl;
		}
		else {
			cout << "??" << inode_table[tempdir.inode_no].fdname << "?????????: " << endl;
			cout << left << setw(15) << "??/?????" << setw(25) << "??????" << setw(10) << "????" << setw(10) << "??§³(B)" << setw(15) << "??????" << setw(10) << "????" << setw(10) << "???????" << endl;
		}

		for (int i = 0; i < tempdir.subsize; i++) {
			if (is_subdir == 1) {
				if (inode_table[tempdir.subinode[i]].filetype == FT_FILE || i == 0 || i == 1) { //??????????/s??????????????????????????????????
					continue;
				}
			}
			//??/?????
			if (i == 0) {
				cout << setw(15) << ".";
			}
			else if (i == 1) {
				cout << setw(15) << "..";
			}
			else {
				cout << setw(15) << inode_table[tempdir.subinode[i]].fdname;
			}

			//??????
			tm temptime = inode_table[tempdir.subinode[i]].mtime.getDatetime();
			cout << setfill('0') << setw(4) << temptime.tm_year + 1900 << "/" << right << setw(2) << temptime.tm_mon + 1 << "/" << setw(2) << temptime.tm_mday << " " << setw(2) << temptime.tm_hour << ":" << setw(2) << temptime.tm_min << ":" << setw(2) << temptime.tm_sec << setfill(' ') << setw(25 - 19) << "";
			cout << left;
			//????
			if (inode_table[tempdir.subinode[i]].filetype == FT_DIR) {
				cout << setw(10) << "??";
			}
			else {
				cout << setw(10) << "???";
			}

			//??§³
			if (inode_table[tempdir.subinode[i]].filetype == FT_DIR) {
				cout << setw(10) << "-";
			}
			else {
				cout << setw(10) << inode_table[tempdir.subinode[i]].filesize;
			}

			//??????
			int j = 0;
			for (j = 0; j < MAX_USER_NUM; j++) {
				if (inode_table[tempdir.subinode[i]].uid == user_group[j].getUserid()) break;
			}
			cout << setw(15) << user_group[j].getUsername();

			//????
			switch (inode_table[tempdir.subinode[i]].fileaccess) {
			case READ_ONLY:
				cout << setw(10) << "???";
				break;
			case WRITE_ONLY:
				cout << setw(10) << "?§Õ";
				break;
			case READ_WRITE:
				cout << setw(10) << "??§Õ";
				break;
			}

			//???????
			cout << setw(10) << inode_table[tempdir.subinode[i]].block_address;
			cout << endl;
		}
	}
	else {
		cout << "????????" << endl;
	}
}

//md ??????
void md(const char *path, fileAccess fileaccess)
{
	Directory tempdir;
	int pathlen = strlen(path);
	char md_dirname[MAX_FILENAME_SIZE];
	if (get_dir_and_fdname(path, pathlen, tempdir, md_dirname)) { //????¡¤???????????????????????????????????
		//?§Ø?i???????????§Õ??
		if (sharedm_read(tempdir.inode_no)) {
			cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}
		//?§Ø????????
		if (inode_table[tempdir.inode_no].fileaccess == READ_ONLY && current_usertype != ROOT_USER) { //?????????????›¯??
			cout << "????????, ?????????????????" << endl;
			return;
		}

		//??????????????
		if (tempdir.samename(md_dirname)) {
			cout << "??????????????????, ?????????" << endl;
			return;
		}

		long md_addr = -1; //????????????????????
		int md_inode = -1; //????????i???
		int b_index; //????????¦Ë??????¦Ë??
		//?????????
		md_addr = block_alloc(DIR_SIZE, b_index);
		if (md_addr < 0) { //?????
			cout << "?????????????????" << endl;
			return;
		}
		else {
			//§Õ??i???????
			int tempindex = sharedm_alloc(tempdir.inode_no);
			if (tempindex == -1) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}
			//????i???
			md_inode = inode_alloc();
			if (md_inode < 0) {
				cout << "i???????????????????" << endl;
				return;
			}

			//??????
			Directory newdir;
			newdir.inode_no = md_inode; //i????
			newdir.subsize = 2; //???????????????????
			strcpy(inode_table[newdir.inode_no].fdname, md_dirname); //????
			newdir.subinode[0] = md_inode; //?????
			newdir.subinode[1] = tempdir.inode_no; //????
			//???i??????
			inode_table[md_inode].blocknum = DIR_SIZE;
			inode_table[md_inode].block_address = md_addr;
			inode_table[md_inode].fileaccess = fileaccess;
			inode_table[md_inode].filesize = sizeof(Directory);
			inode_table[md_inode].filetype = FT_DIR;
			inode_table[md_inode].uid = current_user;
			time_t t;
			time(&t);
			tm local = *localtime(&t);
			inode_table[md_inode].mtime.setDatetime(local);

			//?????????
			tempdir.subinode[tempdir.subsize] = md_inode;
			tempdir.subsize++;
			if (tempdir.inode_no == current_dir.inode_no) {
				current_dir = tempdir;
			}

			//§Õ?????
			int i = 0;
			virtualDisk.open("vfs", ios::out | ios::binary | ios::_Nocreate);
			if (!virtualDisk.is_open()) {
				cout << "§Õ??????????" << endl;
				Sleep(2000);
				exit(0);
			}
			for (i = 0; i < BLOCK_GROUP_NUM; i++) { //§Õ???????
				virtualDisk.write((char*)(&blockgroup[i]), sizeof(Blockgroup));
			}
			//§Õi???¦Ë?
			virtualDisk.seekp(BLOCK_GROUP_NUM * sizeof(Blockgroup) + md_inode * sizeof(Bitmap), ios::beg);
			virtualDisk.write((char*)(&inode_bitmap[md_inode]), sizeof(Bitmap));
			//§Õi????
			virtualDisk.seekp(BLOCK_GROUP_NUM * sizeof(Blockgroup) + TOTAL_INODE_NUM * sizeof(Bitmap) + md_inode * sizeof(Inode), ios::beg);
			virtualDisk.write((char*)(&inode_table[md_inode]), sizeof(Inode));
			//§Õ??¦Ë?
			virtualDisk.seekp(BLOCK_GROUP_NUM * sizeof(Blockgroup) + TOTAL_INODE_NUM * sizeof(Bitmap) + TOTAL_INODE_NUM * sizeof(Inode) + b_index * sizeof(Bitmap), ios::beg);
			for (i = 0; i < DIR_SIZE; i++) {
				virtualDisk.write((char*)(&block_bitmap[b_index]), sizeof(Bitmap));
			}
			//§Õ???????????
			virtualDisk.seekp(md_addr, ios::beg);
			virtualDisk.write((char*)(&newdir), sizeof(Directory));
			virtualDisk.seekp(inode_table[tempdir.inode_no].block_address, ios::beg);
			virtualDisk.write((char*)(&tempdir), sizeof(Directory));
			virtualDisk.close();
			cout << "?????????" << endl;
			//???i??????????
			if (!sharedm_free(tempindex)) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
			}
		}
	}
	else {
		cout << "?????????" << endl;
	}
}

//rd ?????
void rd(const char *path)
{
	Directory tempdir;
	int pathlen = strlen(path);
	char rd_dirname[MAX_FILENAME_SIZE];
	if (get_dir_and_fdname(path, pathlen, tempdir, rd_dirname)) { //????¡¤?????????????????????????????????
		//?§Ø?i???????????§Õ??
		if (sharedm_read(tempdir.inode_no)) {
			cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}

		int i = 0;
		int rd_inode = -1; //???????i???
		int rd_pos = 0; //???????¦Ë??

		//??????????????
		for (i = 2; i < tempdir.subsize; i++) {
			if (strcmp(inode_table[tempdir.subinode[i]].fdname, rd_dirname) == 0 && inode_table[tempdir.subinode[i]].filetype == FT_DIR) {
				rd_inode = tempdir.subinode[i];
				rd_pos = i;
				break;
			}
		}
		if (i == tempdir.subsize) { //?????????
			cout << "????????, ????????" << endl;
			return;
		}
		else { //?????
			Directory rd_dir; //????????
			virtualDisk.open("vfs", ios::in | ios::binary);
			if (!virtualDisk.is_open()) {
				cout << "????????????" << endl;
				Sleep(2000);
				exit(0);
			}
			virtualDisk.seekg(inode_table[rd_inode].block_address, ios::beg);
			virtualDisk.read((char*)(&rd_dir), sizeof(Directory));
			virtualDisk.close();
			if (rd_dir.inode_no == current_dir.inode_no) { //????????????
				cout << "????????????" << endl;
				return;
			}
			if (strstr(current_path, path)) {
				cout << "????????????????¡¤???????" << endl;
				return;
			}

			//?§Ø???????
			if ((current_usertype == USER && inode_table[rd_dir.inode_no].uid != current_user) || inode_table[rd_dir.inode_no].uid == 0) {
				cout << "????????????" << endl;
				return;
			}

			//§Õ??i???????
			int tempindex = sharedm_alloc(tempdir.inode_no);
			if (tempindex == -1) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}
			//§Õ??i???????
			int tempindex2 = sharedm_alloc(rd_dir.inode_no);
			if (tempindex2 == -1) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}

			if (rd_dir.subsize > 2) { //??????????
				char s = '\0';
				while (1) {
					if (s != '\n') cout << "?? " << inode_table[rd_dir.inode_no].fdname << " ?????????????, ?????????? (Y/N) ";
					s = getchar();
					cin.clear();
					cin.ignore();
					if (s == 'Y' || s == 'y' || s == 'N' || s == 'n') {
						break;
					}
				}
				if (s == 'Y' || s == 'y') { //??????????????????????????
					tempdir.remove_dir(rd_dir, rd_pos);
					cout << "????????" << endl;
					return;
				}
				else {
					cout << "????????" << endl;
					return;
				}
				cout << endl;
			}
			else { //?????????????
				//?????i???
				block_free(inode_table[rd_inode].blocknum, ((inode_table[rd_inode].block_address - DATA_BLOCK_BEGIN) / BLOCK_SIZE));
				inode_free(rd_inode);
				//??????????
				for (i = rd_pos; i < tempdir.subsize; i++) {
					tempdir.subinode[i] = tempdir.subinode[i + 1]; //???????????? 
				}
				tempdir.subsize--;
				if (tempdir.inode_no == current_dir.inode_no) {
					current_dir = tempdir;
				}

				//§Õ?????
				virtualDisk.open("vfs", ios::out | ios::binary | ios::_Nocreate);
				if (!virtualDisk.is_open()) {
					cout << "§Õ??????????" << endl;
					Sleep(2000);
					exit(0);
				}
				for (i = 0; i < BLOCK_GROUP_NUM; i++) { //§Õ???????
					virtualDisk.write((char*)(&blockgroup[i]), sizeof(Blockgroup));
				}
				//§Õi???¦Ë?
				virtualDisk.seekp(BLOCK_GROUP_NUM * sizeof(Blockgroup) + rd_inode * sizeof(Bitmap), ios::beg);
				virtualDisk.write((char*)(&inode_bitmap[rd_inode]), sizeof(Bitmap));
				//§Õ??¦Ë?
				virtualDisk.seekp(BLOCK_GROUP_NUM * sizeof(Blockgroup) + TOTAL_INODE_NUM * (sizeof(Bitmap) + sizeof(Inode)) + ((inode_table[rd_inode].block_address - DATA_BLOCK_BEGIN) / BLOCK_SIZE) * sizeof(Bitmap), ios::beg);
				for (i = 0; i < inode_table[rd_inode].blocknum; i++) {
					virtualDisk.write((char*)(&block_bitmap[(inode_table[rd_inode].block_address - DATA_BLOCK_BEGIN) / BLOCK_SIZE]), sizeof(Bitmap));
				}
				//§Õ????
				virtualDisk.seekp(inode_table[tempdir.inode_no].block_address, ios::beg);
				virtualDisk.write((char*)(&tempdir), sizeof(Directory));
				virtualDisk.close();
				cout << "????????" << endl;
			}
			if (!sharedm_free(tempindex2)) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
			}
			if (!sharedm_free(tempindex)) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
			}
		}
	}
	else {
		cout << "????????" << endl;
	}
}

//newfile ???????
void newfile(const char*path, fileAccess fileaccess)
{
	Directory tempdir;
	int pathlen = strlen(path);
	char nf_filename[MAX_FILENAME_SIZE];
	if (get_dir_and_fdname(path, pathlen, tempdir, nf_filename)) { //????¡¤????????????????????????????????????
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}
		//?§Ø????????
		if (inode_table[tempdir.inode_no].fileaccess == READ_ONLY && current_usertype != ROOT_USER) {
			cout << "????????, ????????????????" << endl;
			return;
		}

		//???????????????
		if (tempdir.samename(nf_filename)) {
			cout << "?????????????????, ??????????" << endl;
			return;
		}

		int i = 0;
		int nf_len = 0; //????????
		int nf_size = 16;  //?????§³
		char *content = new char[nf_size]; //???????
		for (i = 0; i < nf_size; i++) {
			content[i] = 0;
		}

		cout << "?????????????, ??#????????" << endl;
		char *temp;
		char s = '\0';
		//??????????????
		while ((s = cin.get()) != '#') {
			content[nf_len++] = s;
			if (nf_len >= nf_size - 1) { //???????????????????§³
				temp = new char[nf_size];
				strcpy(temp, content); //??????????????
				delete(content);
				nf_size *= 2; //?????§³??????????
				content = new char[nf_size];
				for (i = 0; i < nf_size; i++) {
					content[i] = 0;
				}
				strcpy(content, temp);
				delete(temp);
			}
		}
		cin.ignore();

		//?§Ø?i???????????§Õ??
		if (sharedm_read(tempdir.inode_no)) {
			cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}

		//§Õ??i???????
		int tempindex = sharedm_alloc(tempdir.inode_no);
		if (tempindex == -1) {
			cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
			return;
		}
		tempdir.create_file(nf_filename, content, nf_len, fileaccess); //????????????

		//???i??????????
		if (!sharedm_free(tempindex)) {
			cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
		}
		delete(content);
	}
	else {
		cout << "??????????" << endl;
	}
}

//cat ?????
void cat(const char *path)
{
	Directory tempdir;
	int pathlen = strlen(path);
	char cat_filename[MAX_FILENAME_SIZE];
	if (get_dir_and_fdname(path, pathlen, tempdir, cat_filename)) { //????¡¤???????????????????????????????
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "?????????????" << endl;
			return;
		}
		//?§Ø????????
		if (inode_table[tempdir.inode_no].fileaccess == WRITE_ONLY && current_usertype != ROOT_USER) {
			cout << "??????§Õ, ??????????????" << endl;
			return;
		}

		int i = 0;
		int cat_inode = -1; //?????i???
		//???????????
		for (i = 2; i < tempdir.subsize; i++) {
			if (strcmp(inode_table[tempdir.subinode[i]].fdname, cat_filename) == 0 && inode_table[tempdir.subinode[i]].filetype == FT_FILE) {
				cat_inode = tempdir.subinode[i];
				break;
			}
		}
		if (i == tempdir.subsize) { //????????
			cout << "?????????, ????????" << endl;
		}
		else {
			//?§Ø???????
			if (current_usertype == USER && inode_table[cat_inode].uid != current_user && inode_table[cat_inode].uid != 0) {
				cout << "?????????????" << endl;
				return;
			}
			//?§Ø????????
			if (inode_table[cat_inode].fileaccess == WRITE_ONLY) {
				cout << "???????§Õ, ????????" << endl;
				return;
			}

			//?§Ø?i???????????§Õ??
			if (sharedm_read(cat_inode)) {
				cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}

			//????????????????content??
			char *content = new char[inode_table[cat_inode].filesize];
			virtualDisk.open("vfs", ios::in | ios::binary);
			if (!virtualDisk.is_open()) {
				cout << "????????????" << endl;
				Sleep(2000);
				exit(0);
			}
			virtualDisk.seekg(inode_table[cat_inode].block_address, ios::beg);
			virtualDisk.read((char*)(content), inode_table[cat_inode].filesize);
			virtualDisk.close();
			content[inode_table[cat_inode].filesize - 1] = 0;
			//??????????
			cout << "???" << cat_filename << "??????????: " << endl;
			cout << content << endl;
			delete(content);
		}
	}
	else {
		cout << "????????" << endl;
	}
}

//copy ???????
void copy(const char *srcpath, const char *despath)
{
	Directory tempdir;
	char cp_filename[MAX_FILENAME_SIZE];
	char *content; //???????
	char divide;
	int len = 0, i = 0;
	int src_len = strlen(srcpath), des_len = strlen(despath);
	char *f_srcpath = new char[src_len];
	char *f_despath = new char[des_len];
	strcpy(f_srcpath, srcpath);
	strcpy(f_despath, despath);
	//??????????
	if (host_path(f_srcpath)) { //??host????????????????????????
		if (host_path(f_despath)) { //????¡¤?????host¡¤??
			cout << "??????host??????????????host?????" << endl;
			return;
		}

		//???host???
		fstream fsHost;
		fsHost.open(f_srcpath, ios::in | ios::binary);
		if (!fsHost.is_open()) {
			cout << "host??????§Ó?????????" << endl;
			return;
		}
		fsHost.seekg(0, ios::end);
		len = fsHost.tellg(); //???????
		//????›¥???
		content = new char[len];
		content[len - 1] = 0;
		fsHost.seekg(0, ios::beg);
		fsHost.read((char*)(content), len - 1);
		fsHost.close();
		//????????
		divide = '\\';
		strcpy(cp_filename, strrchr(f_srcpath, divide) + 1);
		if (get_dir(f_despath, des_len, tempdir)) { //?????¡¤???????????????

			//?§Ø?i???????????§Õ??
			if (sharedm_read(tempdir.inode_no)) {
				cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}
													
			//?§Ø???????
			if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
				cout << "????????????¡¤??????" << endl;
				delete(content);
				return;
			}
			//?§Ø????????
			if (inode_table[tempdir.inode_no].fileaccess == READ_ONLY && current_usertype != ROOT_USER) {
				cout << "???¡¤??????????, ????????????????" << endl;
				delete(content);
				return;
			}

			//???????????????
			if (tempdir.samename(cp_filename)) {
				cout << "???????????????????, ??????????" << endl;
				delete(content);
				return;
			}

			//§Õ??i???????
			int tempindex = sharedm_alloc(tempdir.inode_no);
			if (tempindex == -1) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
				return;
			}

			//?????????????????
			tempdir.create_file(cp_filename, content, len, READ_WRITE);

			//???i??????????
			if (!sharedm_free(tempindex)) {
				cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
			}
			delete(content);
			cout << "??????????" << endl;
		}
		else {
			cout << "??????????" << endl;
		}
	}
	else { //?????????????????
		if (host_path(f_despath)) { //?????????????????host???????
			if (get_dir_and_fdname(f_srcpath, src_len, tempdir, cp_filename)) { //???¡¤????????????????????
				int cp_inode;
				for (i = 2; i < tempdir.subsize; i++) {
					if (strcmp(inode_table[tempdir.subinode[i]].fdname, cp_filename) == 0 && inode_table[tempdir.subinode[i]].filetype == FT_FILE) { //?????????
						cp_inode = tempdir.subinode[i];
						break;
					}
				}
				if (i == tempdir.subsize) { //????????
					cout << "???????????" << endl;
				}
				else { //??????
					//?§Ø???????
					if (current_usertype == USER && inode_table[cp_inode].uid != current_user) {
						cout << "??????????¡¤???????" << endl;
						return;
					}
					//?§Ø????????
					if (inode_table[cp_inode].fileaccess == WRITE_ONLY && current_usertype != ROOT_USER) {
						cout << "?¡¤?????????§Õ, ???????????????" << endl;
						return;
					}

					//?§Ø?i???????????§Õ??
					if (sharedm_read(cp_inode)) {
						cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
						return;
					}

					//????????????????content??
					content = new char[inode_table[cp_inode].filesize];
					virtualDisk.open("vfs", ios::in | ios::binary);
					if (!virtualDisk.is_open()) {
						cout << "????????????" << endl;
						Sleep(2000);
						exit(0);
					}
					virtualDisk.seekg(inode_table[cp_inode].block_address, ios::beg);
					virtualDisk.read((char*)(content), inode_table[cp_inode].filesize);
					virtualDisk.close();
					content[inode_table[cp_inode].filesize - 1] = 0;
					len = inode_table[cp_inode].filesize;

					//???¡¤??
					char *complete_path = new char[src_len + des_len + 2];
					stringstream sstream;
					sstream << f_despath;
					if (f_despath[des_len - 1] != '\\') sstream << "\\";
					sstream << cp_filename;
					sstream >> complete_path;
					sstream.clear();

					//?????????host?????
					fstream fsHost;
					fsHost.open(complete_path, ios::out | ios::binary);
					if (!fsHost.is_open()) {
						cout << "§Õ???????host????????" << endl;
						delete(content);
						delete(complete_path);
						return;
					}
					fsHost.write((char*)(content), len);
					fsHost.close();
					delete(content);
					delete(complete_path);
					cout << "??????????" << endl;
				}
			}
			else {
				cout << "??????????" << endl;
			}
		}
		else { //???????????????
			if (get_dir_and_fdname(f_srcpath, src_len, tempdir, cp_filename)) { //???¡¤????????????????????
				int cp_inode;
				for (i = 2; i < tempdir.subsize; i++) {
					if (strcmp(inode_table[tempdir.subinode[i]].fdname, cp_filename) == 0 && inode_table[tempdir.subinode[i]].filetype == FT_FILE) { //?????????
						cp_inode = tempdir.subinode[i];
						break;
					}
				}
				if (i == tempdir.subsize) { //????????
					cout << "???????????" << endl;
				}
				else //??????
				{
					//?§Ø???????
					if (current_usertype == USER && inode_table[cp_inode].uid != current_user) {
						cout << "??????????¡¤???????" << endl;
						return;
					}
					//?§Ø????????
					if (inode_table[cp_inode].fileaccess == WRITE_ONLY && current_usertype != ROOT_USER) {
						cout << "?¡¤?????????§Õ, ???????????????" << endl;
						return;
					}

					//?§Ø?i???????????§Õ??
					if (sharedm_read(cp_inode)) {
						cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
						return;
					}

					//????????????????content??
					fileAccess fileaccess = inode_table[cp_inode].fileaccess;
					content = new char[inode_table[cp_inode].filesize];
					virtualDisk.open("vfs", ios::in | ios::binary);
					if (!virtualDisk.is_open()) {
						cout << "????????????" << endl;
						Sleep(2000);
						exit(0);
					}
					virtualDisk.seekg(inode_table[cp_inode].block_address, ios::beg);
					virtualDisk.read((char*)(content), inode_table[cp_inode].filesize);
					virtualDisk.close();
					content[inode_table[cp_inode].filesize - 1] = 0;
					len = inode_table[cp_inode].filesize;

					//???¡¤??
					char *complete_path = new char[src_len + des_len + 2];
					stringstream sstream;
					sstream << f_despath;
					if (f_despath[des_len - 1] != '/') sstream << "/";
					sstream << cp_filename;
					sstream >> complete_path;
					sstream.clear();

					if (get_dir_and_fdname(complete_path, src_len + des_len + 2, tempdir, cp_filename)) { //??¡¤????????????????????
						
						//?§Ø?i???????????§Õ??
						if (sharedm_read(tempdir.inode_no)) {
							cout << "????/????????????????§Õ????????§Ø?§Õ" << endl;
							return;
						}
																										  //?§Ø???????
						if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
							cout << "????????????¡¤??????" << endl;
							delete(content);
							delete(complete_path);
							return;
						}
						//?§Ø????????
						if (inode_table[tempdir.inode_no].fileaccess == READ_ONLY && current_usertype != ROOT_USER) {
							cout << "???¡¤??????????, ????????????????" << endl;
							delete(content);
							delete(complete_path);
							return;
						}

						//???????????????
						if (tempdir.samename(cp_filename)) {
							cout << "???????????????????, ??????????" << endl;
							delete(content);
							delete(complete_path);
							return;
						}

						//§Õ??i???????
						int tempindex = sharedm_alloc(tempdir.inode_no);
						if (tempindex == -1) {
							cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
							return;
						}
						
						//???????
						tempdir.create_file(cp_filename, content, len, fileaccess);
						cout << "??????????" << endl;
						
						//???i??????????
						if (!sharedm_free(tempindex)) {
							cout << "???????????????????§Õ????????§Ø?§Õ" << endl;
						}
					}
					else {
						cout << "??????????" << endl;
					}
					delete(content);
					delete(complete_path);
				}
			}
			else {
				cout << "??????????" << endl;
			}
		}
	}
}

//del ??????
void del(const char *path)
{
	Directory tempdir;
	int pathlen = strlen(path);
	char del_filename[MAX_FILENAME_SIZE];
	if (get_dir_and_fdname(path, pathlen, tempdir, del_filename)) { //????¡¤??????????????????????????????????
		//?§Ø???????
		if (current_usertype == USER && inode_table[tempdir.inode_no].uid != current_user && inode_table[tempdir.inode_no].uid != 0) {
			cout << "????????????" << endl;
			return;
		}
		tempdir.delete_file(del_filename);
	}
	else {
		cout << "?????????" << endl;
	}
}

//check ???????????
void check()
{
	int i = 0, j = 0;
	int free_block_num = 0, free_inode_num = 0, total_free_block = 0, total_free_inode = 0; //???§á?????i??????????§á???????i???????
	int start; //???¦Ë????¦Ë??
	bool error = false; //?????????
	cout << endl;
	cout << "???????????????" << endl;
	for (i = 0; i < BLOCK_GROUP_NUM; i++) {
		free_block_num = 0, free_inode_num = 0;
		start = i * BLOCK_NUM_PER_GROUP;
		for (j = 0; j < BLOCK_NUM_PER_GROUP; j++) {
			if (block_bitmap[start + j] == NOT_USED) free_block_num++; //?????§á???
			if (inode_bitmap[start + j] == NOT_USED) free_inode_num++; //??????i?????
		}
		if (blockgroup[i].groupdescription.group_free_blocks_num != free_block_num) { //???????????
			error = true;
			blockgroup[i].groupdescription.group_free_blocks_num = free_block_num;
		}
		if (blockgroup[i].groupdescription.group_free_inodes_num != free_inode_num) { //???????????
			error = true;
			blockgroup[i].groupdescription.group_free_inodes_num = free_inode_num;
		}
		total_free_block += blockgroup[i].groupdescription.group_free_blocks_num;
		total_free_inode += blockgroup[i].groupdescription.group_free_inodes_num;
	}
	if (blockgroup[0].superblock.free_block_num != total_free_block) { //???????????????
		error = true;
		for (i = 0; i < BLOCK_GROUP_NUM; i++) {
			blockgroup[i].superblock.free_block_num = total_free_block;
		}
	}
	if (blockgroup[0].superblock.free_inode_num != total_free_inode) { //???????????????
		error = true;
		for (i = 0; i < BLOCK_GROUP_NUM; i++) {
			blockgroup[i].superblock.free_inode_num = total_free_inode;
		}
	}
	//?§Ø????????
	if (!error) {
		cout << "??????, ?????????" << endl;
	}
	else {
		//???????
		cout << "??ú€????, ????????????????" << endl;
		virtualDisk.open("vfs", ios::out | ios::binary | ios::_Nocreate);
		if (!virtualDisk.is_open()) {
			cout << "§Õ??????????" << endl;
			Sleep(2000);
			exit(0);
		}
		for (i = 0; i < BLOCK_GROUP_NUM; i++) { //§Õ?????
			virtualDisk.write((char*)(&blockgroup[i]), sizeof(Blockgroup));
		}
		for (i = 0; i < TOTAL_INODE_NUM; i++) { //§Õi???¦Ë?
			virtualDisk.write((char*)(&inode_bitmap[i]), sizeof(Bitmap));
		}
		for (i = 0; i < TOTAL_INODE_NUM; i++) { //§Õi????
			virtualDisk.write((char*)(&inode_table[i]), sizeof(Inode));
		}
		for (i = 0; i < TOTAL_BLOCK_NUM; i++) { //§Õ??¦Ë?
			virtualDisk.write((char*)(&block_bitmap[i]), sizeof(Bitmap));
		}
		//§Õ?????
		virtualDisk.seekp(inode_table[current_dir.inode_no].block_address, ios::beg);
		virtualDisk.write((char*)(&current_dir), sizeof(Directory));
		virtualDisk.close();

		cout << "???????????!" << endl;
	}
}

//help ???????
void help(const char *command_in)
{
	if (command_in[0] == '\0') { //????????
		cout << endl;
		cout << "-------- ???Linux???????????? --------" << endl;
		cout << "0.info" << "\t\t" << "????????????" << endl;
		cout << "1.cd" << "\t\t" << "?§Ý???" << endl;
		cout << "2.dir" << "\t\t" << "?????" << endl;
		cout << "3.md" << "\t\t" << "??????" << endl;
		cout << "4.rd" << "\t\t" << "?????" << endl;
		cout << "5.newfile" << "\t" << "???????" << endl;
		cout << "6.cat" << "\t\t" << "?????" << endl;
		cout << "7.copy" << "\t\t" << "???????" << endl;
		cout << "8.del" << "\t\t" << "??????" << endl;
		cout << "9.check" << "\t\t" << "???????????" << endl;
		cout << "10.help" << "\t\t" << "???????" << endl;
		cout << "11.exit" << "\t\t" << "?????" << endl;
		cout << "12.sync" << "\t\t" << "?????" << endl;
		cout << "?????????????????¡Â???, ????help+??????????" << endl;
	}
	else { //??????
		int i = 0;
		for (i = 0; i < COMMAND_NUM; i++) {
			if (strcmp(command_in, command[i]) == 0) break;
		}
		switch (i)
		{
		case 0: //info ????????????
			cout << "info (????info):\n?????????????????????????????????????????????" << endl;
			break;
		case 1: //cd ?????
			cout << "cd (????cd+¡¤??):\n????????????¡¤????????.????????..??????????????????????????" << endl;
			break;
		case 2: //dir ?????
			cout << "dir (????dir+¡¤??+????):\n???????????????????????????????¡¤????????.????????..???????????????????????????????????????/s???????????????/s?Øb?¡¤??????????" << endl;
			break;
		case 3: //md ??????
			cout << "md (????md+¡¤??+????):\n?????¡¤?????¡¤???????????????????????0??????1??§Õ??2????§Õ?????????§Õ????" << endl;
			break;
		case 4: //rd ?????
			cout << "rd (????rd+¡¤??):\n?????????????????????????" << endl;
			break;
		case 5: //newfile ???????
			cout << "newfile (????newfile+¡¤??(???????????)+????):\n?????¡¤?????¡¤??????????????¡¤????????????????????????????????????????????0??????1??§Õ??2????§Õ?????????§Õ????" << endl;
			break;
		case 6: //cat ?????
			cout << "cat (????cat+¡¤??(?????????)):\n?????¡¤??????????¡¤???????????????????????????????????" << endl;
			break;
		case 7: //copy ???????
			cout << "copy (????copy+?¡¤??(????????)+???¡¤??):\n??????????????????????????????????????host???????????????????????????host???????¡¤????????????????<host>??" << endl;
			break;
		case 8: //del ??????
			cout << "del (????del+¡¤??(??????????)):\n????????????????¡¤????????????????????????????????????" << endl;
			break;
		case 9: //check ???????????
			cout << "check (????check):\n?????????????" << endl;
			break;
		case 10: //help ???????
			cout << "help (????help+??????):\n?????????????????????????????????????????" << endl;
			break;
		case 11: //exit ?????
			cout << "exit (????exit):\n???????" << endl;
			break;
		case 12: //sync ?????
			cout << "sync (????sync):\n???????" << endl;
			break;
		default:
			cout << "??????????????????????????????????" << endl;
			break;
		}
	}
}

//exit ?????
void exit()
{
	//??????
	if (!set_logined_user(current_user, false)) {
		cout << "?????????" << endl;
	}
	CloseFileMap();
	cout << "????????????????" << endl;
	Sleep(2000);
	exit(0);
}

//sync ?????
void sync()
{
	cout << "?????????????" << endl;
	int i = 0;
	virtualDisk.open("vfs", ios::in | ios::binary);
	if (!virtualDisk.is_open()) {
		cout << "§Õ??????????" << endl;
		Sleep(2000);
		exit(0);
	}
	for (i = 0; i < BLOCK_GROUP_NUM; i++) { //???????????
		virtualDisk.read((char*)(&blockgroup[i]), sizeof(Blockgroup));
	}
	for (i = 0; i < TOTAL_INODE_NUM; i++) { //????i???¦Ë?
		virtualDisk.read((char*)(&inode_bitmap[i]), sizeof(Bitmap));
	}
	for (i = 0; i < TOTAL_INODE_NUM; i++) { //????i????
		virtualDisk.read((char*)(&inode_table[i]), sizeof(Inode));
	}
	for (i = 0; i < TOTAL_BLOCK_NUM; i++) { //?????¦Ë?
		virtualDisk.read((char*)(&block_bitmap[i]), sizeof(Bitmap));
	}
	virtualDisk.seekg(inode_table[current_dir.inode_no].block_address, ios::beg);
	virtualDisk.read((char*)(&current_dir), sizeof(Directory));
	virtualDisk.close();
	init_user();

	cout << "??????" << endl;
}